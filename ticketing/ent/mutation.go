// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"ticketing/ent/concert"
	"ticketing/ent/concertsession"
	"ticketing/ent/genre"
	"ticketing/ent/predicate"
	"ticketing/ent/section"
	"ticketing/ent/ticket"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeConcert        = "Concert"
	TypeConcertSession = "ConcertSession"
	TypeGenre          = "Genre"
	TypeSection        = "Section"
	TypeTicket         = "Ticket"
)

// ConcertMutation represents an operation that mutates the Concert nodes in the graph.
type ConcertMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	title                     *string
	artist                    *string
	imageUrl                  *string
	description               *string
	headline                  *string
	featured                  *bool
	clearedFields             map[string]struct{}
	hasConcertSessions        map[uuid.UUID]struct{}
	removedhasConcertSessions map[uuid.UUID]struct{}
	clearedhasConcertSessions bool
	genres                    map[uuid.UUID]struct{}
	removedgenres             map[uuid.UUID]struct{}
	clearedgenres             bool
	done                      bool
	oldValue                  func(context.Context) (*Concert, error)
	predicates                []predicate.Concert
}

var _ ent.Mutation = (*ConcertMutation)(nil)

// concertOption allows management of the mutation configuration using functional options.
type concertOption func(*ConcertMutation)

// newConcertMutation creates new mutation for the Concert entity.
func newConcertMutation(c config, op Op, opts ...concertOption) *ConcertMutation {
	m := &ConcertMutation{
		config:        c,
		op:            op,
		typ:           TypeConcert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConcertID sets the ID field of the mutation.
func withConcertID(id uuid.UUID) concertOption {
	return func(m *ConcertMutation) {
		var (
			err   error
			once  sync.Once
			value *Concert
		)
		m.oldValue = func(ctx context.Context) (*Concert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Concert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConcert sets the old Concert of the mutation.
func withConcert(node *Concert) concertOption {
	return func(m *ConcertMutation) {
		m.oldValue = func(context.Context) (*Concert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConcertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConcertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Concert entities.
func (m *ConcertMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConcertMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConcertMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Concert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ConcertMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ConcertMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Concert entity.
// If the Concert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ConcertMutation) ResetTitle() {
	m.title = nil
}

// SetArtist sets the "artist" field.
func (m *ConcertMutation) SetArtist(s string) {
	m.artist = &s
}

// Artist returns the value of the "artist" field in the mutation.
func (m *ConcertMutation) Artist() (r string, exists bool) {
	v := m.artist
	if v == nil {
		return
	}
	return *v, true
}

// OldArtist returns the old "artist" field's value of the Concert entity.
// If the Concert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertMutation) OldArtist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtist: %w", err)
	}
	return oldValue.Artist, nil
}

// ResetArtist resets all changes to the "artist" field.
func (m *ConcertMutation) ResetArtist() {
	m.artist = nil
}

// SetImageUrl sets the "imageUrl" field.
func (m *ConcertMutation) SetImageUrl(s string) {
	m.imageUrl = &s
}

// ImageUrl returns the value of the "imageUrl" field in the mutation.
func (m *ConcertMutation) ImageUrl() (r string, exists bool) {
	v := m.imageUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldImageUrl returns the old "imageUrl" field's value of the Concert entity.
// If the Concert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertMutation) OldImageUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageUrl: %w", err)
	}
	return oldValue.ImageUrl, nil
}

// ResetImageUrl resets all changes to the "imageUrl" field.
func (m *ConcertMutation) ResetImageUrl() {
	m.imageUrl = nil
}

// SetDescription sets the "description" field.
func (m *ConcertMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConcertMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Concert entity.
// If the Concert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ConcertMutation) ResetDescription() {
	m.description = nil
}

// SetHeadline sets the "headline" field.
func (m *ConcertMutation) SetHeadline(s string) {
	m.headline = &s
}

// Headline returns the value of the "headline" field in the mutation.
func (m *ConcertMutation) Headline() (r string, exists bool) {
	v := m.headline
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadline returns the old "headline" field's value of the Concert entity.
// If the Concert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertMutation) OldHeadline(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadline: %w", err)
	}
	return oldValue.Headline, nil
}

// ResetHeadline resets all changes to the "headline" field.
func (m *ConcertMutation) ResetHeadline() {
	m.headline = nil
}

// SetFeatured sets the "featured" field.
func (m *ConcertMutation) SetFeatured(b bool) {
	m.featured = &b
}

// Featured returns the value of the "featured" field in the mutation.
func (m *ConcertMutation) Featured() (r bool, exists bool) {
	v := m.featured
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatured returns the old "featured" field's value of the Concert entity.
// If the Concert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertMutation) OldFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatured: %w", err)
	}
	return oldValue.Featured, nil
}

// ResetFeatured resets all changes to the "featured" field.
func (m *ConcertMutation) ResetFeatured() {
	m.featured = nil
}

// AddHasConcertSessionIDs adds the "hasConcertSessions" edge to the ConcertSession entity by ids.
func (m *ConcertMutation) AddHasConcertSessionIDs(ids ...uuid.UUID) {
	if m.hasConcertSessions == nil {
		m.hasConcertSessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hasConcertSessions[ids[i]] = struct{}{}
	}
}

// ClearHasConcertSessions clears the "hasConcertSessions" edge to the ConcertSession entity.
func (m *ConcertMutation) ClearHasConcertSessions() {
	m.clearedhasConcertSessions = true
}

// HasConcertSessionsCleared reports if the "hasConcertSessions" edge to the ConcertSession entity was cleared.
func (m *ConcertMutation) HasConcertSessionsCleared() bool {
	return m.clearedhasConcertSessions
}

// RemoveHasConcertSessionIDs removes the "hasConcertSessions" edge to the ConcertSession entity by IDs.
func (m *ConcertMutation) RemoveHasConcertSessionIDs(ids ...uuid.UUID) {
	if m.removedhasConcertSessions == nil {
		m.removedhasConcertSessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hasConcertSessions, ids[i])
		m.removedhasConcertSessions[ids[i]] = struct{}{}
	}
}

// RemovedHasConcertSessions returns the removed IDs of the "hasConcertSessions" edge to the ConcertSession entity.
func (m *ConcertMutation) RemovedHasConcertSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removedhasConcertSessions {
		ids = append(ids, id)
	}
	return
}

// HasConcertSessionsIDs returns the "hasConcertSessions" edge IDs in the mutation.
func (m *ConcertMutation) HasConcertSessionsIDs() (ids []uuid.UUID) {
	for id := range m.hasConcertSessions {
		ids = append(ids, id)
	}
	return
}

// ResetHasConcertSessions resets all changes to the "hasConcertSessions" edge.
func (m *ConcertMutation) ResetHasConcertSessions() {
	m.hasConcertSessions = nil
	m.clearedhasConcertSessions = false
	m.removedhasConcertSessions = nil
}

// AddGenreIDs adds the "genres" edge to the Genre entity by ids.
func (m *ConcertMutation) AddGenreIDs(ids ...uuid.UUID) {
	if m.genres == nil {
		m.genres = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.genres[ids[i]] = struct{}{}
	}
}

// ClearGenres clears the "genres" edge to the Genre entity.
func (m *ConcertMutation) ClearGenres() {
	m.clearedgenres = true
}

// GenresCleared reports if the "genres" edge to the Genre entity was cleared.
func (m *ConcertMutation) GenresCleared() bool {
	return m.clearedgenres
}

// RemoveGenreIDs removes the "genres" edge to the Genre entity by IDs.
func (m *ConcertMutation) RemoveGenreIDs(ids ...uuid.UUID) {
	if m.removedgenres == nil {
		m.removedgenres = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.genres, ids[i])
		m.removedgenres[ids[i]] = struct{}{}
	}
}

// RemovedGenres returns the removed IDs of the "genres" edge to the Genre entity.
func (m *ConcertMutation) RemovedGenresIDs() (ids []uuid.UUID) {
	for id := range m.removedgenres {
		ids = append(ids, id)
	}
	return
}

// GenresIDs returns the "genres" edge IDs in the mutation.
func (m *ConcertMutation) GenresIDs() (ids []uuid.UUID) {
	for id := range m.genres {
		ids = append(ids, id)
	}
	return
}

// ResetGenres resets all changes to the "genres" edge.
func (m *ConcertMutation) ResetGenres() {
	m.genres = nil
	m.clearedgenres = false
	m.removedgenres = nil
}

// Where appends a list predicates to the ConcertMutation builder.
func (m *ConcertMutation) Where(ps ...predicate.Concert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConcertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConcertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Concert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConcertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConcertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Concert).
func (m *ConcertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConcertMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, concert.FieldTitle)
	}
	if m.artist != nil {
		fields = append(fields, concert.FieldArtist)
	}
	if m.imageUrl != nil {
		fields = append(fields, concert.FieldImageUrl)
	}
	if m.description != nil {
		fields = append(fields, concert.FieldDescription)
	}
	if m.headline != nil {
		fields = append(fields, concert.FieldHeadline)
	}
	if m.featured != nil {
		fields = append(fields, concert.FieldFeatured)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConcertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case concert.FieldTitle:
		return m.Title()
	case concert.FieldArtist:
		return m.Artist()
	case concert.FieldImageUrl:
		return m.ImageUrl()
	case concert.FieldDescription:
		return m.Description()
	case concert.FieldHeadline:
		return m.Headline()
	case concert.FieldFeatured:
		return m.Featured()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConcertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case concert.FieldTitle:
		return m.OldTitle(ctx)
	case concert.FieldArtist:
		return m.OldArtist(ctx)
	case concert.FieldImageUrl:
		return m.OldImageUrl(ctx)
	case concert.FieldDescription:
		return m.OldDescription(ctx)
	case concert.FieldHeadline:
		return m.OldHeadline(ctx)
	case concert.FieldFeatured:
		return m.OldFeatured(ctx)
	}
	return nil, fmt.Errorf("unknown Concert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConcertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case concert.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case concert.FieldArtist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtist(v)
		return nil
	case concert.FieldImageUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageUrl(v)
		return nil
	case concert.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case concert.FieldHeadline:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadline(v)
		return nil
	case concert.FieldFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatured(v)
		return nil
	}
	return fmt.Errorf("unknown Concert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConcertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConcertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConcertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Concert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConcertMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConcertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConcertMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Concert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConcertMutation) ResetField(name string) error {
	switch name {
	case concert.FieldTitle:
		m.ResetTitle()
		return nil
	case concert.FieldArtist:
		m.ResetArtist()
		return nil
	case concert.FieldImageUrl:
		m.ResetImageUrl()
		return nil
	case concert.FieldDescription:
		m.ResetDescription()
		return nil
	case concert.FieldHeadline:
		m.ResetHeadline()
		return nil
	case concert.FieldFeatured:
		m.ResetFeatured()
		return nil
	}
	return fmt.Errorf("unknown Concert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConcertMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hasConcertSessions != nil {
		edges = append(edges, concert.EdgeHasConcertSessions)
	}
	if m.genres != nil {
		edges = append(edges, concert.EdgeGenres)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConcertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case concert.EdgeHasConcertSessions:
		ids := make([]ent.Value, 0, len(m.hasConcertSessions))
		for id := range m.hasConcertSessions {
			ids = append(ids, id)
		}
		return ids
	case concert.EdgeGenres:
		ids := make([]ent.Value, 0, len(m.genres))
		for id := range m.genres {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConcertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhasConcertSessions != nil {
		edges = append(edges, concert.EdgeHasConcertSessions)
	}
	if m.removedgenres != nil {
		edges = append(edges, concert.EdgeGenres)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConcertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case concert.EdgeHasConcertSessions:
		ids := make([]ent.Value, 0, len(m.removedhasConcertSessions))
		for id := range m.removedhasConcertSessions {
			ids = append(ids, id)
		}
		return ids
	case concert.EdgeGenres:
		ids := make([]ent.Value, 0, len(m.removedgenres))
		for id := range m.removedgenres {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConcertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhasConcertSessions {
		edges = append(edges, concert.EdgeHasConcertSessions)
	}
	if m.clearedgenres {
		edges = append(edges, concert.EdgeGenres)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConcertMutation) EdgeCleared(name string) bool {
	switch name {
	case concert.EdgeHasConcertSessions:
		return m.clearedhasConcertSessions
	case concert.EdgeGenres:
		return m.clearedgenres
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConcertMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Concert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConcertMutation) ResetEdge(name string) error {
	switch name {
	case concert.EdgeHasConcertSessions:
		m.ResetHasConcertSessions()
		return nil
	case concert.EdgeGenres:
		m.ResetGenres()
		return nil
	}
	return fmt.Errorf("unknown Concert edge %s", name)
}

// ConcertSessionMutation represents an operation that mutates the ConcertSession nodes in the graph.
type ConcertSessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	sessionDateTime    *int
	addsessionDateTime *int
	clearedFields      map[string]struct{}
	ofConcert          map[uuid.UUID]struct{}
	removedofConcert   map[uuid.UUID]struct{}
	clearedofConcert   bool
	hasSections        map[uuid.UUID]struct{}
	removedhasSections map[uuid.UUID]struct{}
	clearedhasSections bool
	done               bool
	oldValue           func(context.Context) (*ConcertSession, error)
	predicates         []predicate.ConcertSession
}

var _ ent.Mutation = (*ConcertSessionMutation)(nil)

// concertsessionOption allows management of the mutation configuration using functional options.
type concertsessionOption func(*ConcertSessionMutation)

// newConcertSessionMutation creates new mutation for the ConcertSession entity.
func newConcertSessionMutation(c config, op Op, opts ...concertsessionOption) *ConcertSessionMutation {
	m := &ConcertSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeConcertSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConcertSessionID sets the ID field of the mutation.
func withConcertSessionID(id uuid.UUID) concertsessionOption {
	return func(m *ConcertSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *ConcertSession
		)
		m.oldValue = func(ctx context.Context) (*ConcertSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConcertSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConcertSession sets the old ConcertSession of the mutation.
func withConcertSession(node *ConcertSession) concertsessionOption {
	return func(m *ConcertSessionMutation) {
		m.oldValue = func(context.Context) (*ConcertSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConcertSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConcertSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConcertSession entities.
func (m *ConcertSessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConcertSessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConcertSessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConcertSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionDateTime sets the "sessionDateTime" field.
func (m *ConcertSessionMutation) SetSessionDateTime(i int) {
	m.sessionDateTime = &i
	m.addsessionDateTime = nil
}

// SessionDateTime returns the value of the "sessionDateTime" field in the mutation.
func (m *ConcertSessionMutation) SessionDateTime() (r int, exists bool) {
	v := m.sessionDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionDateTime returns the old "sessionDateTime" field's value of the ConcertSession entity.
// If the ConcertSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConcertSessionMutation) OldSessionDateTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionDateTime: %w", err)
	}
	return oldValue.SessionDateTime, nil
}

// AddSessionDateTime adds i to the "sessionDateTime" field.
func (m *ConcertSessionMutation) AddSessionDateTime(i int) {
	if m.addsessionDateTime != nil {
		*m.addsessionDateTime += i
	} else {
		m.addsessionDateTime = &i
	}
}

// AddedSessionDateTime returns the value that was added to the "sessionDateTime" field in this mutation.
func (m *ConcertSessionMutation) AddedSessionDateTime() (r int, exists bool) {
	v := m.addsessionDateTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetSessionDateTime resets all changes to the "sessionDateTime" field.
func (m *ConcertSessionMutation) ResetSessionDateTime() {
	m.sessionDateTime = nil
	m.addsessionDateTime = nil
}

// AddOfConcertIDs adds the "ofConcert" edge to the Concert entity by ids.
func (m *ConcertSessionMutation) AddOfConcertIDs(ids ...uuid.UUID) {
	if m.ofConcert == nil {
		m.ofConcert = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ofConcert[ids[i]] = struct{}{}
	}
}

// ClearOfConcert clears the "ofConcert" edge to the Concert entity.
func (m *ConcertSessionMutation) ClearOfConcert() {
	m.clearedofConcert = true
}

// OfConcertCleared reports if the "ofConcert" edge to the Concert entity was cleared.
func (m *ConcertSessionMutation) OfConcertCleared() bool {
	return m.clearedofConcert
}

// RemoveOfConcertIDs removes the "ofConcert" edge to the Concert entity by IDs.
func (m *ConcertSessionMutation) RemoveOfConcertIDs(ids ...uuid.UUID) {
	if m.removedofConcert == nil {
		m.removedofConcert = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ofConcert, ids[i])
		m.removedofConcert[ids[i]] = struct{}{}
	}
}

// RemovedOfConcert returns the removed IDs of the "ofConcert" edge to the Concert entity.
func (m *ConcertSessionMutation) RemovedOfConcertIDs() (ids []uuid.UUID) {
	for id := range m.removedofConcert {
		ids = append(ids, id)
	}
	return
}

// OfConcertIDs returns the "ofConcert" edge IDs in the mutation.
func (m *ConcertSessionMutation) OfConcertIDs() (ids []uuid.UUID) {
	for id := range m.ofConcert {
		ids = append(ids, id)
	}
	return
}

// ResetOfConcert resets all changes to the "ofConcert" edge.
func (m *ConcertSessionMutation) ResetOfConcert() {
	m.ofConcert = nil
	m.clearedofConcert = false
	m.removedofConcert = nil
}

// AddHasSectionIDs adds the "hasSections" edge to the Section entity by ids.
func (m *ConcertSessionMutation) AddHasSectionIDs(ids ...uuid.UUID) {
	if m.hasSections == nil {
		m.hasSections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hasSections[ids[i]] = struct{}{}
	}
}

// ClearHasSections clears the "hasSections" edge to the Section entity.
func (m *ConcertSessionMutation) ClearHasSections() {
	m.clearedhasSections = true
}

// HasSectionsCleared reports if the "hasSections" edge to the Section entity was cleared.
func (m *ConcertSessionMutation) HasSectionsCleared() bool {
	return m.clearedhasSections
}

// RemoveHasSectionIDs removes the "hasSections" edge to the Section entity by IDs.
func (m *ConcertSessionMutation) RemoveHasSectionIDs(ids ...uuid.UUID) {
	if m.removedhasSections == nil {
		m.removedhasSections = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hasSections, ids[i])
		m.removedhasSections[ids[i]] = struct{}{}
	}
}

// RemovedHasSections returns the removed IDs of the "hasSections" edge to the Section entity.
func (m *ConcertSessionMutation) RemovedHasSectionsIDs() (ids []uuid.UUID) {
	for id := range m.removedhasSections {
		ids = append(ids, id)
	}
	return
}

// HasSectionsIDs returns the "hasSections" edge IDs in the mutation.
func (m *ConcertSessionMutation) HasSectionsIDs() (ids []uuid.UUID) {
	for id := range m.hasSections {
		ids = append(ids, id)
	}
	return
}

// ResetHasSections resets all changes to the "hasSections" edge.
func (m *ConcertSessionMutation) ResetHasSections() {
	m.hasSections = nil
	m.clearedhasSections = false
	m.removedhasSections = nil
}

// Where appends a list predicates to the ConcertSessionMutation builder.
func (m *ConcertSessionMutation) Where(ps ...predicate.ConcertSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConcertSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConcertSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConcertSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConcertSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConcertSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConcertSession).
func (m *ConcertSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConcertSessionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.sessionDateTime != nil {
		fields = append(fields, concertsession.FieldSessionDateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConcertSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case concertsession.FieldSessionDateTime:
		return m.SessionDateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConcertSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case concertsession.FieldSessionDateTime:
		return m.OldSessionDateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ConcertSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConcertSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case concertsession.FieldSessionDateTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionDateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ConcertSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConcertSessionMutation) AddedFields() []string {
	var fields []string
	if m.addsessionDateTime != nil {
		fields = append(fields, concertsession.FieldSessionDateTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConcertSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case concertsession.FieldSessionDateTime:
		return m.AddedSessionDateTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConcertSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case concertsession.FieldSessionDateTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSessionDateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ConcertSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConcertSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConcertSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConcertSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConcertSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConcertSessionMutation) ResetField(name string) error {
	switch name {
	case concertsession.FieldSessionDateTime:
		m.ResetSessionDateTime()
		return nil
	}
	return fmt.Errorf("unknown ConcertSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConcertSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.ofConcert != nil {
		edges = append(edges, concertsession.EdgeOfConcert)
	}
	if m.hasSections != nil {
		edges = append(edges, concertsession.EdgeHasSections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConcertSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case concertsession.EdgeOfConcert:
		ids := make([]ent.Value, 0, len(m.ofConcert))
		for id := range m.ofConcert {
			ids = append(ids, id)
		}
		return ids
	case concertsession.EdgeHasSections:
		ids := make([]ent.Value, 0, len(m.hasSections))
		for id := range m.hasSections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConcertSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedofConcert != nil {
		edges = append(edges, concertsession.EdgeOfConcert)
	}
	if m.removedhasSections != nil {
		edges = append(edges, concertsession.EdgeHasSections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConcertSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case concertsession.EdgeOfConcert:
		ids := make([]ent.Value, 0, len(m.removedofConcert))
		for id := range m.removedofConcert {
			ids = append(ids, id)
		}
		return ids
	case concertsession.EdgeHasSections:
		ids := make([]ent.Value, 0, len(m.removedhasSections))
		for id := range m.removedhasSections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConcertSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedofConcert {
		edges = append(edges, concertsession.EdgeOfConcert)
	}
	if m.clearedhasSections {
		edges = append(edges, concertsession.EdgeHasSections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConcertSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case concertsession.EdgeOfConcert:
		return m.clearedofConcert
	case concertsession.EdgeHasSections:
		return m.clearedhasSections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConcertSessionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ConcertSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConcertSessionMutation) ResetEdge(name string) error {
	switch name {
	case concertsession.EdgeOfConcert:
		m.ResetOfConcert()
		return nil
	case concertsession.EdgeHasSections:
		m.ResetHasSections()
		return nil
	}
	return fmt.Errorf("unknown ConcertSession edge %s", name)
}

// GenreMutation represents an operation that mutates the Genre nodes in the graph.
type GenreMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	name            *string
	clearedFields   map[string]struct{}
	concerts        map[uuid.UUID]struct{}
	removedconcerts map[uuid.UUID]struct{}
	clearedconcerts bool
	done            bool
	oldValue        func(context.Context) (*Genre, error)
	predicates      []predicate.Genre
}

var _ ent.Mutation = (*GenreMutation)(nil)

// genreOption allows management of the mutation configuration using functional options.
type genreOption func(*GenreMutation)

// newGenreMutation creates new mutation for the Genre entity.
func newGenreMutation(c config, op Op, opts ...genreOption) *GenreMutation {
	m := &GenreMutation{
		config:        c,
		op:            op,
		typ:           TypeGenre,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenreID sets the ID field of the mutation.
func withGenreID(id uuid.UUID) genreOption {
	return func(m *GenreMutation) {
		var (
			err   error
			once  sync.Once
			value *Genre
		)
		m.oldValue = func(ctx context.Context) (*Genre, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Genre.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGenre sets the old Genre of the mutation.
func withGenre(node *Genre) genreOption {
	return func(m *GenreMutation) {
		m.oldValue = func(context.Context) (*Genre, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Genre entities.
func (m *GenreMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GenreMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GenreMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Genre.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GenreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GenreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Genre entity.
// If the Genre object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GenreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GenreMutation) ResetName() {
	m.name = nil
}

// AddConcertIDs adds the "concerts" edge to the Concert entity by ids.
func (m *GenreMutation) AddConcertIDs(ids ...uuid.UUID) {
	if m.concerts == nil {
		m.concerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.concerts[ids[i]] = struct{}{}
	}
}

// ClearConcerts clears the "concerts" edge to the Concert entity.
func (m *GenreMutation) ClearConcerts() {
	m.clearedconcerts = true
}

// ConcertsCleared reports if the "concerts" edge to the Concert entity was cleared.
func (m *GenreMutation) ConcertsCleared() bool {
	return m.clearedconcerts
}

// RemoveConcertIDs removes the "concerts" edge to the Concert entity by IDs.
func (m *GenreMutation) RemoveConcertIDs(ids ...uuid.UUID) {
	if m.removedconcerts == nil {
		m.removedconcerts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.concerts, ids[i])
		m.removedconcerts[ids[i]] = struct{}{}
	}
}

// RemovedConcerts returns the removed IDs of the "concerts" edge to the Concert entity.
func (m *GenreMutation) RemovedConcertsIDs() (ids []uuid.UUID) {
	for id := range m.removedconcerts {
		ids = append(ids, id)
	}
	return
}

// ConcertsIDs returns the "concerts" edge IDs in the mutation.
func (m *GenreMutation) ConcertsIDs() (ids []uuid.UUID) {
	for id := range m.concerts {
		ids = append(ids, id)
	}
	return
}

// ResetConcerts resets all changes to the "concerts" edge.
func (m *GenreMutation) ResetConcerts() {
	m.concerts = nil
	m.clearedconcerts = false
	m.removedconcerts = nil
}

// Where appends a list predicates to the GenreMutation builder.
func (m *GenreMutation) Where(ps ...predicate.Genre) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GenreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GenreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Genre, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GenreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GenreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Genre).
func (m *GenreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GenreMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, genre.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GenreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case genre.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GenreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case genre.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Genre field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case genre.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Genre field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GenreMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GenreMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GenreMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Genre numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GenreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GenreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Genre nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GenreMutation) ResetField(name string) error {
	switch name {
	case genre.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Genre field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GenreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.concerts != nil {
		edges = append(edges, genre.EdgeConcerts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GenreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case genre.EdgeConcerts:
		ids := make([]ent.Value, 0, len(m.concerts))
		for id := range m.concerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GenreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedconcerts != nil {
		edges = append(edges, genre.EdgeConcerts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GenreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case genre.EdgeConcerts:
		ids := make([]ent.Value, 0, len(m.removedconcerts))
		for id := range m.removedconcerts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GenreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconcerts {
		edges = append(edges, genre.EdgeConcerts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GenreMutation) EdgeCleared(name string) bool {
	switch name {
	case genre.EdgeConcerts:
		return m.clearedconcerts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GenreMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Genre unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GenreMutation) ResetEdge(name string) error {
	switch name {
	case genre.EdgeConcerts:
		m.ResetConcerts()
		return nil
	}
	return fmt.Errorf("unknown Genre edge %s", name)
}

// SectionMutation represents an operation that mutates the Section nodes in the graph.
type SectionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	name                    *string
	capacity                *int
	addcapacity             *int
	reserved                *int
	addreserved             *int
	bought                  *int
	addbought               *int
	category                *section.Category
	price                   *int
	addprice                *int
	clearedFields           map[string]struct{}
	hasTickets              map[uuid.UUID]struct{}
	removedhasTickets       map[uuid.UUID]struct{}
	clearedhasTickets       bool
	atConcertSession        *uuid.UUID
	clearedatConcertSession bool
	done                    bool
	oldValue                func(context.Context) (*Section, error)
	predicates              []predicate.Section
}

var _ ent.Mutation = (*SectionMutation)(nil)

// sectionOption allows management of the mutation configuration using functional options.
type sectionOption func(*SectionMutation)

// newSectionMutation creates new mutation for the Section entity.
func newSectionMutation(c config, op Op, opts ...sectionOption) *SectionMutation {
	m := &SectionMutation{
		config:        c,
		op:            op,
		typ:           TypeSection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSectionID sets the ID field of the mutation.
func withSectionID(id uuid.UUID) sectionOption {
	return func(m *SectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Section
		)
		m.oldValue = func(ctx context.Context) (*Section, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Section.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSection sets the old Section of the mutation.
func withSection(node *Section) sectionOption {
	return func(m *SectionMutation) {
		m.oldValue = func(context.Context) (*Section, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Section entities.
func (m *SectionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SectionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SectionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Section.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SectionMutation) ResetName() {
	m.name = nil
}

// SetCapacity sets the "capacity" field.
func (m *SectionMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *SectionMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *SectionMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *SectionMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *SectionMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// SetReserved sets the "reserved" field.
func (m *SectionMutation) SetReserved(i int) {
	m.reserved = &i
	m.addreserved = nil
}

// Reserved returns the value of the "reserved" field in the mutation.
func (m *SectionMutation) Reserved() (r int, exists bool) {
	v := m.reserved
	if v == nil {
		return
	}
	return *v, true
}

// OldReserved returns the old "reserved" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldReserved(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReserved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReserved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReserved: %w", err)
	}
	return oldValue.Reserved, nil
}

// AddReserved adds i to the "reserved" field.
func (m *SectionMutation) AddReserved(i int) {
	if m.addreserved != nil {
		*m.addreserved += i
	} else {
		m.addreserved = &i
	}
}

// AddedReserved returns the value that was added to the "reserved" field in this mutation.
func (m *SectionMutation) AddedReserved() (r int, exists bool) {
	v := m.addreserved
	if v == nil {
		return
	}
	return *v, true
}

// ResetReserved resets all changes to the "reserved" field.
func (m *SectionMutation) ResetReserved() {
	m.reserved = nil
	m.addreserved = nil
}

// SetBought sets the "bought" field.
func (m *SectionMutation) SetBought(i int) {
	m.bought = &i
	m.addbought = nil
}

// Bought returns the value of the "bought" field in the mutation.
func (m *SectionMutation) Bought() (r int, exists bool) {
	v := m.bought
	if v == nil {
		return
	}
	return *v, true
}

// OldBought returns the old "bought" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldBought(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBought is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBought requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBought: %w", err)
	}
	return oldValue.Bought, nil
}

// AddBought adds i to the "bought" field.
func (m *SectionMutation) AddBought(i int) {
	if m.addbought != nil {
		*m.addbought += i
	} else {
		m.addbought = &i
	}
}

// AddedBought returns the value that was added to the "bought" field in this mutation.
func (m *SectionMutation) AddedBought() (r int, exists bool) {
	v := m.addbought
	if v == nil {
		return
	}
	return *v, true
}

// ResetBought resets all changes to the "bought" field.
func (m *SectionMutation) ResetBought() {
	m.bought = nil
	m.addbought = nil
}

// SetCategory sets the "category" field.
func (m *SectionMutation) SetCategory(s section.Category) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *SectionMutation) Category() (r section.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldCategory(ctx context.Context) (v section.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *SectionMutation) ResetCategory() {
	m.category = nil
}

// SetPrice sets the "price" field.
func (m *SectionMutation) SetPrice(i int) {
	m.price = &i
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SectionMutation) Price() (r int, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Section entity.
// If the Section object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SectionMutation) OldPrice(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds i to the "price" field.
func (m *SectionMutation) AddPrice(i int) {
	if m.addprice != nil {
		*m.addprice += i
	} else {
		m.addprice = &i
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SectionMutation) AddedPrice() (r int, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *SectionMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// AddHasTicketIDs adds the "hasTickets" edge to the Ticket entity by ids.
func (m *SectionMutation) AddHasTicketIDs(ids ...uuid.UUID) {
	if m.hasTickets == nil {
		m.hasTickets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hasTickets[ids[i]] = struct{}{}
	}
}

// ClearHasTickets clears the "hasTickets" edge to the Ticket entity.
func (m *SectionMutation) ClearHasTickets() {
	m.clearedhasTickets = true
}

// HasTicketsCleared reports if the "hasTickets" edge to the Ticket entity was cleared.
func (m *SectionMutation) HasTicketsCleared() bool {
	return m.clearedhasTickets
}

// RemoveHasTicketIDs removes the "hasTickets" edge to the Ticket entity by IDs.
func (m *SectionMutation) RemoveHasTicketIDs(ids ...uuid.UUID) {
	if m.removedhasTickets == nil {
		m.removedhasTickets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hasTickets, ids[i])
		m.removedhasTickets[ids[i]] = struct{}{}
	}
}

// RemovedHasTickets returns the removed IDs of the "hasTickets" edge to the Ticket entity.
func (m *SectionMutation) RemovedHasTicketsIDs() (ids []uuid.UUID) {
	for id := range m.removedhasTickets {
		ids = append(ids, id)
	}
	return
}

// HasTicketsIDs returns the "hasTickets" edge IDs in the mutation.
func (m *SectionMutation) HasTicketsIDs() (ids []uuid.UUID) {
	for id := range m.hasTickets {
		ids = append(ids, id)
	}
	return
}

// ResetHasTickets resets all changes to the "hasTickets" edge.
func (m *SectionMutation) ResetHasTickets() {
	m.hasTickets = nil
	m.clearedhasTickets = false
	m.removedhasTickets = nil
}

// SetAtConcertSessionID sets the "atConcertSession" edge to the ConcertSession entity by id.
func (m *SectionMutation) SetAtConcertSessionID(id uuid.UUID) {
	m.atConcertSession = &id
}

// ClearAtConcertSession clears the "atConcertSession" edge to the ConcertSession entity.
func (m *SectionMutation) ClearAtConcertSession() {
	m.clearedatConcertSession = true
}

// AtConcertSessionCleared reports if the "atConcertSession" edge to the ConcertSession entity was cleared.
func (m *SectionMutation) AtConcertSessionCleared() bool {
	return m.clearedatConcertSession
}

// AtConcertSessionID returns the "atConcertSession" edge ID in the mutation.
func (m *SectionMutation) AtConcertSessionID() (id uuid.UUID, exists bool) {
	if m.atConcertSession != nil {
		return *m.atConcertSession, true
	}
	return
}

// AtConcertSessionIDs returns the "atConcertSession" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AtConcertSessionID instead. It exists only for internal usage by the builders.
func (m *SectionMutation) AtConcertSessionIDs() (ids []uuid.UUID) {
	if id := m.atConcertSession; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAtConcertSession resets all changes to the "atConcertSession" edge.
func (m *SectionMutation) ResetAtConcertSession() {
	m.atConcertSession = nil
	m.clearedatConcertSession = false
}

// Where appends a list predicates to the SectionMutation builder.
func (m *SectionMutation) Where(ps ...predicate.Section) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Section, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Section).
func (m *SectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SectionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, section.FieldName)
	}
	if m.capacity != nil {
		fields = append(fields, section.FieldCapacity)
	}
	if m.reserved != nil {
		fields = append(fields, section.FieldReserved)
	}
	if m.bought != nil {
		fields = append(fields, section.FieldBought)
	}
	if m.category != nil {
		fields = append(fields, section.FieldCategory)
	}
	if m.price != nil {
		fields = append(fields, section.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case section.FieldName:
		return m.Name()
	case section.FieldCapacity:
		return m.Capacity()
	case section.FieldReserved:
		return m.Reserved()
	case section.FieldBought:
		return m.Bought()
	case section.FieldCategory:
		return m.Category()
	case section.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case section.FieldName:
		return m.OldName(ctx)
	case section.FieldCapacity:
		return m.OldCapacity(ctx)
	case section.FieldReserved:
		return m.OldReserved(ctx)
	case section.FieldBought:
		return m.OldBought(ctx)
	case section.FieldCategory:
		return m.OldCategory(ctx)
	case section.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown Section field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case section.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case section.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case section.FieldReserved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReserved(v)
		return nil
	case section.FieldBought:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBought(v)
		return nil
	case section.FieldCategory:
		v, ok := value.(section.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case section.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Section field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SectionMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, section.FieldCapacity)
	}
	if m.addreserved != nil {
		fields = append(fields, section.FieldReserved)
	}
	if m.addbought != nil {
		fields = append(fields, section.FieldBought)
	}
	if m.addprice != nil {
		fields = append(fields, section.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case section.FieldCapacity:
		return m.AddedCapacity()
	case section.FieldReserved:
		return m.AddedReserved()
	case section.FieldBought:
		return m.AddedBought()
	case section.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case section.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	case section.FieldReserved:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReserved(v)
		return nil
	case section.FieldBought:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBought(v)
		return nil
	case section.FieldPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Section numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Section nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SectionMutation) ResetField(name string) error {
	switch name {
	case section.FieldName:
		m.ResetName()
		return nil
	case section.FieldCapacity:
		m.ResetCapacity()
		return nil
	case section.FieldReserved:
		m.ResetReserved()
		return nil
	case section.FieldBought:
		m.ResetBought()
		return nil
	case section.FieldCategory:
		m.ResetCategory()
		return nil
	case section.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown Section field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.hasTickets != nil {
		edges = append(edges, section.EdgeHasTickets)
	}
	if m.atConcertSession != nil {
		edges = append(edges, section.EdgeAtConcertSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case section.EdgeHasTickets:
		ids := make([]ent.Value, 0, len(m.hasTickets))
		for id := range m.hasTickets {
			ids = append(ids, id)
		}
		return ids
	case section.EdgeAtConcertSession:
		if id := m.atConcertSession; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhasTickets != nil {
		edges = append(edges, section.EdgeHasTickets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case section.EdgeHasTickets:
		ids := make([]ent.Value, 0, len(m.removedhasTickets))
		for id := range m.removedhasTickets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhasTickets {
		edges = append(edges, section.EdgeHasTickets)
	}
	if m.clearedatConcertSession {
		edges = append(edges, section.EdgeAtConcertSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SectionMutation) EdgeCleared(name string) bool {
	switch name {
	case section.EdgeHasTickets:
		return m.clearedhasTickets
	case section.EdgeAtConcertSession:
		return m.clearedatConcertSession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SectionMutation) ClearEdge(name string) error {
	switch name {
	case section.EdgeAtConcertSession:
		m.ClearAtConcertSession()
		return nil
	}
	return fmt.Errorf("unknown Section unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SectionMutation) ResetEdge(name string) error {
	switch name {
	case section.EdgeHasTickets:
		m.ResetHasTickets()
		return nil
	case section.EdgeAtConcertSession:
		m.ResetAtConcertSession()
		return nil
	}
	return fmt.Errorf("unknown Section edge %s", name)
}

// TicketMutation represents an operation that mutates the Ticket nodes in the graph.
type TicketMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	seatNumber           *int
	addseatNumber        *int
	status               *ticket.Status
	userId               *uuid.UUID
	reservedAt           *int
	addreservedAt        *int
	clearedFields        map[string]struct{}
	withinSection        *uuid.UUID
	clearedwithinSection bool
	done                 bool
	oldValue             func(context.Context) (*Ticket, error)
	predicates           []predicate.Ticket
}

var _ ent.Mutation = (*TicketMutation)(nil)

// ticketOption allows management of the mutation configuration using functional options.
type ticketOption func(*TicketMutation)

// newTicketMutation creates new mutation for the Ticket entity.
func newTicketMutation(c config, op Op, opts ...ticketOption) *TicketMutation {
	m := &TicketMutation{
		config:        c,
		op:            op,
		typ:           TypeTicket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTicketID sets the ID field of the mutation.
func withTicketID(id uuid.UUID) ticketOption {
	return func(m *TicketMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticket
		)
		m.oldValue = func(ctx context.Context) (*Ticket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicket sets the old Ticket of the mutation.
func withTicket(node *Ticket) ticketOption {
	return func(m *TicketMutation) {
		m.oldValue = func(context.Context) (*Ticket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TicketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TicketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticket entities.
func (m *TicketMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TicketMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TicketMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeatNumber sets the "seatNumber" field.
func (m *TicketMutation) SetSeatNumber(i int) {
	m.seatNumber = &i
	m.addseatNumber = nil
}

// SeatNumber returns the value of the "seatNumber" field in the mutation.
func (m *TicketMutation) SeatNumber() (r int, exists bool) {
	v := m.seatNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatNumber returns the old "seatNumber" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldSeatNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatNumber: %w", err)
	}
	return oldValue.SeatNumber, nil
}

// AddSeatNumber adds i to the "seatNumber" field.
func (m *TicketMutation) AddSeatNumber(i int) {
	if m.addseatNumber != nil {
		*m.addseatNumber += i
	} else {
		m.addseatNumber = &i
	}
}

// AddedSeatNumber returns the value that was added to the "seatNumber" field in this mutation.
func (m *TicketMutation) AddedSeatNumber() (r int, exists bool) {
	v := m.addseatNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeatNumber resets all changes to the "seatNumber" field.
func (m *TicketMutation) ResetSeatNumber() {
	m.seatNumber = nil
	m.addseatNumber = nil
}

// SetStatus sets the "status" field.
func (m *TicketMutation) SetStatus(t ticket.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TicketMutation) Status() (r ticket.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldStatus(ctx context.Context) (v ticket.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TicketMutation) ResetStatus() {
	m.status = nil
}

// SetUserId sets the "userId" field.
func (m *TicketMutation) SetUserId(u uuid.UUID) {
	m.userId = &u
}

// UserId returns the value of the "userId" field in the mutation.
func (m *TicketMutation) UserId() (r uuid.UUID, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "userId" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldUserId(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "userId" field.
func (m *TicketMutation) ClearUserId() {
	m.userId = nil
	m.clearedFields[ticket.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "userId" field was cleared in this mutation.
func (m *TicketMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[ticket.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "userId" field.
func (m *TicketMutation) ResetUserId() {
	m.userId = nil
	delete(m.clearedFields, ticket.FieldUserId)
}

// SetReservedAt sets the "reservedAt" field.
func (m *TicketMutation) SetReservedAt(i int) {
	m.reservedAt = &i
	m.addreservedAt = nil
}

// ReservedAt returns the value of the "reservedAt" field in the mutation.
func (m *TicketMutation) ReservedAt() (r int, exists bool) {
	v := m.reservedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldReservedAt returns the old "reservedAt" field's value of the Ticket entity.
// If the Ticket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TicketMutation) OldReservedAt(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservedAt: %w", err)
	}
	return oldValue.ReservedAt, nil
}

// AddReservedAt adds i to the "reservedAt" field.
func (m *TicketMutation) AddReservedAt(i int) {
	if m.addreservedAt != nil {
		*m.addreservedAt += i
	} else {
		m.addreservedAt = &i
	}
}

// AddedReservedAt returns the value that was added to the "reservedAt" field in this mutation.
func (m *TicketMutation) AddedReservedAt() (r int, exists bool) {
	v := m.addreservedAt
	if v == nil {
		return
	}
	return *v, true
}

// ClearReservedAt clears the value of the "reservedAt" field.
func (m *TicketMutation) ClearReservedAt() {
	m.reservedAt = nil
	m.addreservedAt = nil
	m.clearedFields[ticket.FieldReservedAt] = struct{}{}
}

// ReservedAtCleared returns if the "reservedAt" field was cleared in this mutation.
func (m *TicketMutation) ReservedAtCleared() bool {
	_, ok := m.clearedFields[ticket.FieldReservedAt]
	return ok
}

// ResetReservedAt resets all changes to the "reservedAt" field.
func (m *TicketMutation) ResetReservedAt() {
	m.reservedAt = nil
	m.addreservedAt = nil
	delete(m.clearedFields, ticket.FieldReservedAt)
}

// SetWithinSectionID sets the "withinSection" edge to the Section entity by id.
func (m *TicketMutation) SetWithinSectionID(id uuid.UUID) {
	m.withinSection = &id
}

// ClearWithinSection clears the "withinSection" edge to the Section entity.
func (m *TicketMutation) ClearWithinSection() {
	m.clearedwithinSection = true
}

// WithinSectionCleared reports if the "withinSection" edge to the Section entity was cleared.
func (m *TicketMutation) WithinSectionCleared() bool {
	return m.clearedwithinSection
}

// WithinSectionID returns the "withinSection" edge ID in the mutation.
func (m *TicketMutation) WithinSectionID() (id uuid.UUID, exists bool) {
	if m.withinSection != nil {
		return *m.withinSection, true
	}
	return
}

// WithinSectionIDs returns the "withinSection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WithinSectionID instead. It exists only for internal usage by the builders.
func (m *TicketMutation) WithinSectionIDs() (ids []uuid.UUID) {
	if id := m.withinSection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWithinSection resets all changes to the "withinSection" edge.
func (m *TicketMutation) ResetWithinSection() {
	m.withinSection = nil
	m.clearedwithinSection = false
}

// Where appends a list predicates to the TicketMutation builder.
func (m *TicketMutation) Where(ps ...predicate.Ticket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TicketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TicketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ticket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TicketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TicketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ticket).
func (m *TicketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TicketMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.seatNumber != nil {
		fields = append(fields, ticket.FieldSeatNumber)
	}
	if m.status != nil {
		fields = append(fields, ticket.FieldStatus)
	}
	if m.userId != nil {
		fields = append(fields, ticket.FieldUserId)
	}
	if m.reservedAt != nil {
		fields = append(fields, ticket.FieldReservedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TicketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldSeatNumber:
		return m.SeatNumber()
	case ticket.FieldStatus:
		return m.Status()
	case ticket.FieldUserId:
		return m.UserId()
	case ticket.FieldReservedAt:
		return m.ReservedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TicketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticket.FieldSeatNumber:
		return m.OldSeatNumber(ctx)
	case ticket.FieldStatus:
		return m.OldStatus(ctx)
	case ticket.FieldUserId:
		return m.OldUserId(ctx)
	case ticket.FieldReservedAt:
		return m.OldReservedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ticket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldSeatNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatNumber(v)
		return nil
	case ticket.FieldStatus:
		v, ok := value.(ticket.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ticket.FieldUserId:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case ticket.FieldReservedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TicketMutation) AddedFields() []string {
	var fields []string
	if m.addseatNumber != nil {
		fields = append(fields, ticket.FieldSeatNumber)
	}
	if m.addreservedAt != nil {
		fields = append(fields, ticket.FieldReservedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TicketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticket.FieldSeatNumber:
		return m.AddedSeatNumber()
	case ticket.FieldReservedAt:
		return m.AddedReservedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TicketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticket.FieldSeatNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeatNumber(v)
		return nil
	case ticket.FieldReservedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReservedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ticket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TicketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ticket.FieldUserId) {
		fields = append(fields, ticket.FieldUserId)
	}
	if m.FieldCleared(ticket.FieldReservedAt) {
		fields = append(fields, ticket.FieldReservedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TicketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TicketMutation) ClearField(name string) error {
	switch name {
	case ticket.FieldUserId:
		m.ClearUserId()
		return nil
	case ticket.FieldReservedAt:
		m.ClearReservedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TicketMutation) ResetField(name string) error {
	switch name {
	case ticket.FieldSeatNumber:
		m.ResetSeatNumber()
		return nil
	case ticket.FieldStatus:
		m.ResetStatus()
		return nil
	case ticket.FieldUserId:
		m.ResetUserId()
		return nil
	case ticket.FieldReservedAt:
		m.ResetReservedAt()
		return nil
	}
	return fmt.Errorf("unknown Ticket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TicketMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.withinSection != nil {
		edges = append(edges, ticket.EdgeWithinSection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TicketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticket.EdgeWithinSection:
		if id := m.withinSection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TicketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TicketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TicketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwithinSection {
		edges = append(edges, ticket.EdgeWithinSection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TicketMutation) EdgeCleared(name string) bool {
	switch name {
	case ticket.EdgeWithinSection:
		return m.clearedwithinSection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TicketMutation) ClearEdge(name string) error {
	switch name {
	case ticket.EdgeWithinSection:
		m.ClearWithinSection()
		return nil
	}
	return fmt.Errorf("unknown Ticket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TicketMutation) ResetEdge(name string) error {
	switch name {
	case ticket.EdgeWithinSection:
		m.ResetWithinSection()
		return nil
	}
	return fmt.Errorf("unknown Ticket edge %s", name)
}
